			+--------------------+
			|       CS 330       |
			| PROJECT 1: THREADS |
			|   DESIGN DOCUMENT  |
			+--------------------+
				   
---- GROUP ----

>> Fill in the names and email addresses of your group members.

Team 27
  김정우 <souldomination@kaist.ac.kr>
  김동균 <kdgyun425@kaist.ac.kr>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, usage of tokens, or extra credit, please give them here.

none.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

https://knowledgejunk.net/2011/05/06/avoiding-busy-wait-in-timer_sleep-on-pintos/

			     ALARM CLOCK
			     ===========

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

struct thread:

    int64_t wake_up_tick;

  When the thread gets into sleeping, this variable stores the tick when
  the thread must wake up.

In thread.c:

    static struct list sleeping_list;

  This is the list of all sleeping threads.

---- ALGORITHMS ----

>> A2: Briefly describe what happens in a call to timer_sleep(),
>> including the effects of the timer interrupt handler.

First, timer_sleep() disables the interrupt and calls thread_sleep() in thread.c.
thread_sleep() takes a tick when the sleeping thread to wake up and puts the thread
into sleeping_list with the tick, then blocks it. Here if the thread is idle then
ignore since idle thread cannot sleep.

Getting back to timer_sleep(), it restores the interrupt level to the previous. At
each tick the timer interrupt handler calls thread_tick(). In this context, 
check_sleeping_list() checks sleeping_list and take off the threads to wake up,
then unblocks them.

>> A3: What steps are taken to minimize the amount of time spent in
>> the timer interrupt handler?

When we put the thread into the sleeping_list, we used list_insert_ordered() to
keep the sleeping_list sorted by wake_up_tick of each thread in increasing order.
This allows that only the front thread in sleeping_list can be checked when we want
to know that there exists a thread to wake up. Since the front thread has the least
value of wake_up_tick among all other sleeping threads. If that value is smaller
than the current tick, we can assure that there is no thread to wake up, thus the
function can be returned immediately.

The another way to implement is using list_push_back in thread_sleep() and
list_min() in check_sleeping_list(). However, this implementation shows a large
overhead since check_sleeping_list() is called every tick while thread_sleep() is
called several times only. Thus, it is more important to reduce the overhead in
check_sleeping_list(). We spent a little time for inserting and reduced much time
for checking.


---- SYNCHRONIZATION ----

>> A4: How are race conditions avoided when multiple threads call
>> timer_sleep() simultaneously?

By disabling the interrupt during timer_sleep().

>> A5: How are race conditions avoided when a timer interrupt occurs
>> during a call to timer_sleep()?

Same as A4; the interrupt is also disabled.


---- RATIONALE ----

>> A6: Why did you choose this design?  In what ways is it superior to
>> another design you considered?

We minimized the overhead. By using busy waiting, sleeping thread repeats yielding
and running until it wakes up. This makes a lot of overhead since context switching
occurs every tick. In contrast, blocking the thread prevents the sleeping thread
from getting into running state and idle thread is able to run when every threads
are sleeping.

			 PRIORITY SCHEDULING
			 ===================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

struct thread:

    int priority_original;
  
  This stores the "original" priority of a thread.

    struct lock *lock_waiting;

  The lock that a thread is waiting. It must be initialized to NULL in init_thread().

    struct list lock_holding_list;

  List of all locks that a thread is holding.

struct lock:

    struct list_elem elem;

  To make a list of locks.

>> B2: Explain the data structure used to track priority donation.
>> Use ASCII art to diagram a nested donation.  (Alternately, submit a
>> .png file.)

When a thread tries to acquire a lock, its lock_waiting is set to the lock and it
is added to waiters of semaphore of lock. Then, priority donation occurs.

1) If priority of the holder is less than priority of the current thread, replace
   it with priority of the current thread.
2) If the holder is waiting for another lock (this can be checked using lock_waiting
   of the holder) and this lock also has a holder, donates the priority to that
   thread.

By iterating the above steps, it can donate its priority to all nested threads.
After donating (if the lock has holder), waits for the holder release the lock and
finally acquire the lock, with setting lock_waiting of the thread to point NULL and
add the lock to of lock_holding_list.

priority_original contains the "original" priority as mentioned above. It remains
same when priority donation occurs. It is replaced only when the thread calls
thread_set_priority.
Consider a thread which releases a lock. If there is no thread which is waiting a
lock held by it or all waiters of all locks have lower priority than the priority
of it then its priority is set to priority_original to restore priority donation.
If not, re-calculate effective priority. In addtion to setting priority, some more
tasks are needed: holder of the lock must be set to NULL and the lock is removed
from lock_holding_list of the thread.


e.g.)

1)
Let there be three threads T1, T2, and T3, whose original priorities are 31, 32,
and 33, respectively. At the beginning, T1 holds the lock L1 and T2 holds the lock
L2.

        T1                      T2                      T3
------------------      ------------------      ------------------
priority:     31        priority:     32        priority:     33
lock_waiting: NULL      lock_waiting: NULL      lock_waiting: NULL
------------------      ------------------      ------------------
lock_holding_list:      lock_holding_list:      lock_holding_list:
  L1                      L2                      NULL
------------------      ------------------      ------------------

2)
T2 tries to acquire L1, which is held by T1 already. Thus T2 waits T1 and it
donates its priority to T1; priority of T1 is changed to 32. (priority_original
remains same)

        T1                                              T3
------------------                              ------------------
priority:     32                                priority:     33
lock_waiting: NULL              T2              lock_waiting: NULL
------------------      ------------------      ------------------
lock_holding_list:      priority:     32        lock_holding_list:
  L1               <--- lock_waiting: L1          (empty)
------------------      ------------------      ------------------
                        lock_holding_list:
                          L2
                        ------------------

3)
T3 tries to acquire L2, which is held by T2 already. Thus T3 waits T2 and it
donates its priority to T2; priority of T2 is changed to 33. (priority_original
remains same)
T2 also waits another thread T1. (lock_waiting of T2 is L1; holder of L1 is T1.)
Since the priority of T1 (32) is less than 33, it is changed to 33.
(Nested donation)

        T1
------------------
priority:     33
lock_waiting: NULL              T2
------------------      ------------------
lock_holding_list:      priority:     33
  L1               <--- lock_waiting: L1                T3
------------------      ------------------      ------------------
                        lock_holding_list:      priority:     33
                          L2               <--- lock_waiting: L2
                        ------------------      ------------------
                                                lock_holding_list:
                                                  (empty)
                                                ------------------

3)
T1 releases L1. L1 is removed from lock_holding_list of T1. Theres no thread
which is wating a lock held by T1 (because T1 does not have a lock), so priority
of T1 becomes its original priority, 31. Now T2 acquired L1, and it does not
wait any lock. lock_waiting of T2 becomes NULL. L1 is added to lock_holding_list
of T2.

        T1                      T2
------------------      ------------------
priority:     31        priority:     33
lock_waiting: NULL      lock_waiting: NULL              T3
------------------      ------------------      ------------------
lock_holding_list:      lock_holding_list:      priority:     33
  (empty)                 L2               <--- lock_waiting: L2
------------------        L1                    ------------------
                        ------------------      lock_holding_list:
                                                  (empty)
                                                ------------------

4)
T2 releases L2. L2 is removed from lock_holding_list of T2. Priority of T2 becomes
its original priority, 32. Now T3 acquired L2 and lock_waiting of T3 becomes NULL.
L2 is added to lock_holding_list of T3.

        T1                      T2                      T3
------------------      ------------------      ------------------
priority:     31        priority:     32        priority:     33
lock_waiting: NULL      lock_waiting: NULL      lock_waiting: NULL
------------------      ------------------      ------------------
lock_holding_list:      lock_holding_list:      lock_holding_list:
  (empty)                 L1                      L2
------------------      ------------------      ------------------

---- ALGORITHMS ----

>> B3: How do you ensure that the highest priority thread waiting for
>> a lock, semaphore, or condition variable wakes up first?

In function sema_up(), the thread with maximum priority in wating list of semaphore
is selected to be unblocked by using list_min(). (Same for condition)

>> B4: Describe the sequence of events when a call to lock_acquire()
>> causes a priority donation.  How is nested donation handled?

First, lock_waiting of the current thread is set to LOCK. Then priority donation
occurs. Let L be LOCK and H be holder of LOCK.

1) If H is NULL, L is not held by any other thread, or there is no thread to donate
   priority. No priority donation is needed.
2) If priority of H is less than priority of the current thrad, set it to priority
   of the current thread. Otherwise, no priority donation is needed.
3) If H is waiting another lock, nested donation is needed. Let L be lock_waiting
   of H and H be holder of L.
4) Repeat 1) - 3).

  struct lock *l = lock;
  struct thread *h = lock->holder;

  while (h != NULL && h->priority < curr->priority)
    {
      h->priority = curr->priority;
      if (h->lock_waiting != NULL)
        {
          l = h->lock_waiting;
          h = l->holder;
        }
    }

After priority donation, call sema_down() to acquire LOCK. After aquiring,
lock_waiting of the current thread becomes NULL, holder of LOCK becomes the currernt
thread, and LOCK is added to lock_holding_list of that thread.

>> B5: Describe the sequence of events when lock_release() is called
>> on a lock that a higher-priority thread is waiting for.

First, LOCK is removed from lock_holding_list of the current thread and holder of
LOCK is set to NULL. Then, priority donation must be restored.

1) If no thread waits LOCK, priority does not have to be changed.
2) Set priority of the current thread to its priority_original.
3) If there is any thread which is waiting the current thread through some lock,
   select the thread with maximum priority among them.
4) If its priority is greater than priority of the current thread, replace.

Using this algorithm, multiple donation problem is also be handled. After restoring,
call sema_up().

---- SYNCHRONIZATION ----

>> B6: Describe a potential race in thread_set_priority() and explain
>> how your implementation avoids it.  Can you use a lock to avoid
>> this race?

The one possible case is that thread_set_priority() is called during priority
donation. For example, consider that thread T1 (original priority 31) is holding
lock L and thread T2 (original priority 32) waits L. At the same time, T1 calls
thread_set_priority (30). If priority donation performs first, priority of T1 is
changed to 32 by donation, and set to 30. If thread_set_priority performs first,
priority of T1 is set to 30, and changed to 32 by donation.

In this implementation, the interrupt is disabled during priority donation and
thread_set_priority() so this race can be avoided. However, a lock cannot be used
to avoid this race. Assume that priority donation must be performed first. Then,

1) T1 holds L.
2) T2 waits L.
3) Make a new lock for race avoidance, say LR.
4) priority donation first: T2 holds LR and T1 waits it. T2 will release LR after
   priority donation occurs.

Now T2 waits T1 because of L, and at the same time T1 waits T2 because of LR.
I.e. two threads get into a deadlock.

---- RATIONALE ----

>> B7: Why did you choose this design?  In what ways is it superior to
>> another design you considered?

If a thread with high priority (say, H) is waiting for a thread with lower
priority (say, L), H cannot be executed until L's execution is finished. To avoid
this situation, we implemented priority donation.

After releasing the lock, L should restore its original priority, so that H can be
scheduled prior than L. To do this, we added new member variable priority_original
to 'struct thread'.

There's another problem in this. If a H is waiting for a thread with L which is
waiting for medium priority (say, M), H cannot be executed until execution of M is
finished. Therefore we implemented nested priority donation, so that H can be
scheduled prior than M.

			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?
